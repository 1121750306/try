#### 什么是策略模式
定义一系列的算法,把它们一个个封装起来,并且使它们可以相互替换。即：能够根据不同的条件，执行不同的算法。或者，定义一系列的算法,把它们各自封装成策略类,算法被封装在策略类内部的方法里。

#### 使用策略模式进行奖金的计算
题意大致为，不同的绩效会发不同份数的年终奖。
1. 最初的代码：
```JavaScript
var calculateBonus = function( performanceLevel, salary ){
  if ( performanceLevel === 'S' ){
    return salary * 4;
  }
  if ( performanceLevel === 'A' ){
    return salary * 3;
  }
  if ( performanceLevel === 'B' ){
    return salary * 2;
  }
};


calculateBonus( 'B', 20000 );
calculateBonus( 'S', 6000 );
// 输出:40000
// 输出:24000
```
这是写法最简单的代码，但是它有很多缺点：
  * 包含了很多的if-else语句，需要覆盖所有的逻辑分支 
  * 代码缺乏弹性，如果需要增加一种绩效等级，则需要进入函数内部去修改代码
  * 复用性太差，其他地方需要用到计算奖金的算法，只能整个复制粘贴


2. 使用组合函数重构代码
    将各种算法封装到一个个小的函数内部，能够很显然的看出这些方法的作用，也能够被其他程序所复用：
```JavaScript
var performanceS = function( salary ){
  return salary * 4;
};
var performanceA = function( salary ){
  return salary * 3;
};
var performanceB = function( salary ){
  return salary * 2;
};
var calculateBonus = function( performanceLevel, salary ){
  if ( performanceLevel === 'S' ){
    return performanceS( salary );
  } 
  if ( performanceLevel === 'A' ){
    return performanceA( salary );
  } 
  if ( performanceLevel === 'B' ){
    return performanceB( salary );
  }
};

calculateBonus('A' , 10000 );
// 输出:30000
```
    改善的地方，只有计算奖金的算法能够被调用

3. 使用策略模式重构代码
    策略模式是指，定义一系列算法，把他们封装起来。和其他设计模式的宗旨一样，不变的部分和变化的部分需要被分开。

    首先，先把每种绩效的计算规则封装在各自的策略类里面：
```JavaScript
var performanceS = function(){};
performanceS.prototype.calculate = function( salary ){
  return salary * 4;
};
var performanceA = function(){};
performanceA.prototype.calculate = function( salary ){
  return salary * 3;
};
var performanceB = function(){};
performanceB.prototype.calculate = function( salary ){
  return salary * 2;
};
```
   接下来定义奖金这个类：
```JavaScript
var Bonus = function(){
  this.salary = null;
  this.strategy = null;
};
// 原始工资
// 绩效等级对应的策略对象
Bonus.prototype.setSalary = function( salary ){
  this.salary = salary;  // 设置员工的原始工资
};
Bonus.prototype.setStrategy = function( strategy ){
  this.strategy = strategy;  // 设置员工绩效等级对应的策略对象
};
Bonus.prototype.getBonus = function(){
// 取得奖金数额
  return this.strategy.calculate( this.salary );  // 把计算奖金的操作委托给对应的策略对象
};
```
   最后创建具体对象来完成最后代码：
```JavaScript
var bonus = new Bonus();
bonus.setSalary( 10000 );
bonus.setStrategy( new performanceS() );
console.log( bonus.getBonus() );
// 设置策略对象
// 输出:40000
bonus.setStrategy( new performanceA() ); // 设置策略对象
console.log( bonus.getBonus() );
// 输出:30000
```
